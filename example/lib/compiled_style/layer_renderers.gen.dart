// GENERATED FILE - DO NOT MODIFY
// Generated by lib/src/style_precompiler_2/style_precompiler.dart

// ignore_for_file: unused_local_variable, non_constant_identifier_names

import 'package:gpu_vector_tile_renderer/_controller.dart';
import 'package:gpu_vector_tile_renderer/_renderer.dart';
import 'package:gpu_vector_tile_renderer/_utils.dart';
import 'package:gpu_vector_tile_renderer/_spec.dart' as spec;
import 'package:gpu_vector_tile_renderer/_vector_tile.dart' as vt;
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter_map/flutter_map.dart';

import './shader_bindings.gen.dart';

const shaderBundleName = 'Streets.shaderbundle';

SingleTileLayerRenderer? createSingleTileLayerRenderer(
  gpu.ShaderLibrary shaderLibrary,
  TileCoordinates coordinates,
  TileContainer container,
  spec.Layer specLayer,
  vt.Layer vtLayer,
) {
  return switch (specLayer.id) {
    'Meadow' => MeadowLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Scrub' => ScrubLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Crop' => CropLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Glacier' => GlacierLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Forest' => ForestLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Sand' => SandLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Wood' => WoodLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Residential' => ResidentialLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Industrial' => IndustrialLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Grass' => GrassLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Airport zone' => AirportZoneLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Pedestrian' => PedestrianLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Cemetery' => CemeteryLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Hospital' => HospitalLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Stadium' => StadiumLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'School' => SchoolLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Water intermittent' => WaterIntermittentLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Water' => WaterLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Heliport' => HeliportLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Pier' => PierLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Bridge' => BridgeLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    'Building' => BuildingLayerRenderer(
      shaderLibrary: shaderLibrary,
      coordinates: coordinates,
      container: container,
      specLayer: specLayer as spec.LayerFill,
      vtLayer: vtLayer,
    ),
    _ => null,
  };
}

class MeadowLayerRenderer extends FillLayerRenderer {
  MeadowLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = MeadowRenderPipelineBindings(shaderLibrary);

  @override
  final MeadowRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [0.0, 8.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [0.0, 8.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [0.0, 8.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [0.0, 8.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      meadowUboOpacityStartStop: opacity_start_stop,
      meadowUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class ScrubLayerRenderer extends FillLayerRenderer {
  ScrubLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ScrubRenderPipelineBindings(shaderLibrary);

  @override
  final ScrubRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [0.0, 8.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [0.0, 8.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [0.0, 8.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [0.0, 8.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      scrubUboOpacityStartStop: opacity_start_stop,
      scrubUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class CropLayerRenderer extends FillLayerRenderer {
  CropLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CropRenderPipelineBindings(shaderLibrary);

  @override
  final CropRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [0.0, 8.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [0.0, 8.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [0.0, 8.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [0.0, 8.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cropUboOpacityStartStop: opacity_start_stop,
      cropUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class GlacierLayerRenderer extends FillLayerRenderer {
  GlacierLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = GlacierRenderPipelineBindings(shaderLibrary);

  @override
  final GlacierRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [0.0, 10.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [0.0, 10.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [0.0, 10.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [0.0, 10.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      glacierUboOpacityStartStop: opacity_start_stop,
      glacierUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class ForestLayerRenderer extends FillLayerRenderer {
  ForestLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ForestRenderPipelineBindings(shaderLibrary);

  @override
  final ForestRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [1.0, 8.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [1.0, 8.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [1.0, 8.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [1.0, 8.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      forestUboOpacityStartStop: opacity_start_stop,
      forestUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class SandLayerRenderer extends FillLayerRenderer {
  SandLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = SandRenderPipelineBindings(shaderLibrary);

  @override
  final SandRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class WoodLayerRenderer extends FillLayerRenderer {
  WoodLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WoodRenderPipelineBindings(shaderLibrary);

  @override
  final WoodRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class ResidentialLayerRenderer extends FillLayerRenderer {
  ResidentialLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = ResidentialRenderPipelineBindings(shaderLibrary);

  @override
  final ResidentialRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final color_start_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [4.0, 16.0])),
            )
            .vec;
    final color_end_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [4.0, 16.0])),
            )
            .vec;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          colorStartValue: color_start_value,
          colorEndValue: color_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final color_start_stop = getNearestFloorValue(eval.zoom, [4.0, 16.0]);
    final color_end_stop = getNearestCeilValue(eval.zoom, [4.0, 16.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      residentialUboColorStartStop: color_start_stop,
      residentialUboColorEndStop: color_end_stop,
    );
  }
}

class IndustrialLayerRenderer extends FillLayerRenderer {
  IndustrialLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = IndustrialRenderPipelineBindings(shaderLibrary);

  @override
  final IndustrialRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [9.0, 10.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [9.0, 10.0])),
            )
            .toDouble();
    final color_start_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [9.0, 16.0])),
            )
            .vec;
    final color_end_value =
        paint.fillColor
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [9.0, 16.0])),
            )
            .vec;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
          colorStartValue: color_start_value,
          colorEndValue: color_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [9.0, 10.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [9.0, 10.0]);
    final color_start_stop = getNearestFloorValue(eval.zoom, [9.0, 16.0]);
    final color_end_stop = getNearestCeilValue(eval.zoom, [9.0, 16.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      industrialUboOpacityStartStop: opacity_start_stop,
      industrialUboOpacityEndStop: opacity_end_stop,
      industrialUboColorStartStop: color_start_stop,
      industrialUboColorEndStop: color_end_stop,
    );
  }
}

class GrassLayerRenderer extends FillLayerRenderer {
  GrassLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = GrassRenderPipelineBindings(shaderLibrary);

  @override
  final GrassRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class AirportZoneLayerRenderer extends FillLayerRenderer {
  AirportZoneLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = AirportZoneRenderPipelineBindings(shaderLibrary);

  @override
  final AirportZoneRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class PedestrianLayerRenderer extends FillLayerRenderer {
  PedestrianLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PedestrianRenderPipelineBindings(shaderLibrary);

  @override
  final PedestrianRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class CemeteryLayerRenderer extends FillLayerRenderer {
  CemeteryLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = CemeteryRenderPipelineBindings(shaderLibrary);

  @override
  final CemeteryRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [9.0, 16.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [9.0, 16.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      cemeteryUboOpacityStartStop: opacity_start_stop,
      cemeteryUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class HospitalLayerRenderer extends FillLayerRenderer {
  HospitalLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HospitalRenderPipelineBindings(shaderLibrary);

  @override
  final HospitalRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [9.0, 16.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [9.0, 16.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      hospitalUboOpacityStartStop: opacity_start_stop,
      hospitalUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class StadiumLayerRenderer extends FillLayerRenderer {
  StadiumLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = StadiumRenderPipelineBindings(shaderLibrary);

  @override
  final StadiumRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [9.0, 16.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [9.0, 16.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      stadiumUboOpacityStartStop: opacity_start_stop,
      stadiumUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class SchoolLayerRenderer extends FillLayerRenderer {
  SchoolLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = SchoolRenderPipelineBindings(shaderLibrary);

  @override
  final SchoolRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity_start_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestFloorValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();
    final opacity_end_value =
        paint.fillOpacity
            .evaluate(
              eval.copyWithZoom(getNearestCeilValue(eval.zoom, [9.0, 16.0])),
            )
            .toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacityStartValue: opacity_start_value,
          opacityEndValue: opacity_end_value,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;
    final opacity_start_stop = getNearestFloorValue(eval.zoom, [9.0, 16.0]);
    final opacity_end_stop = getNearestCeilValue(eval.zoom, [9.0, 16.0]);

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
      schoolUboOpacityStartStop: opacity_start_stop,
      schoolUboOpacityEndStop: opacity_end_stop,
    );
  }
}

class WaterIntermittentLayerRenderer extends FillLayerRenderer {
  WaterIntermittentLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WaterIntermittentRenderPipelineBindings(shaderLibrary);

  @override
  final WaterIntermittentRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class WaterLayerRenderer extends FillLayerRenderer {
  WaterLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = WaterRenderPipelineBindings(shaderLibrary);

  @override
  final WaterRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;
    final opacity = paint.fillOpacity.evaluate(eval).toDouble();

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(
          index,
          position: vertex.vec2,
          opacity: opacity,
        );
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class HeliportLayerRenderer extends FillLayerRenderer {
  HeliportLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = HeliportRenderPipelineBindings(shaderLibrary);

  @override
  final HeliportRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class PierLayerRenderer extends FillLayerRenderer {
  PierLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = PierRenderPipelineBindings(shaderLibrary);

  @override
  final PierRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class BridgeLayerRenderer extends FillLayerRenderer {
  BridgeLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BridgeRenderPipelineBindings(shaderLibrary);

  @override
  final BridgeRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}

class BuildingLayerRenderer extends FillLayerRenderer {
  BuildingLayerRenderer({
    required gpu.ShaderLibrary shaderLibrary,
    required super.coordinates,
    required super.container,
    required super.specLayer,
    required super.vtLayer,
  }) : pipeline = BuildingRenderPipelineBindings(shaderLibrary);

  @override
  final BuildingRenderPipelineBindings pipeline;

  @override
  int setFeatureVertices(
    spec.EvaluationContext eval,
    vt.PolygonFeature feature,
    int index,
  ) {
    final paint = specLayer.paint;

    for (final polygon in feature.polygons) {
      for (final vertex in polygon.vertices) {
        pipeline.vertex.setVertex(index, position: vertex.vec2);
        index += 1;
      }
    }

    return index;
  }

  @override
  void setUniforms(
    RenderContext context,
    Matrix4 cameraWorldToGl,
    double cameraZoom,
    Matrix4 tileLocalToWorld,
    double tileSize,
    double tileExtent,
    double tileOpacity,
  ) {
    final eval = context.eval;

    pipeline.setUbos(
      cameraWorldToGl: cameraWorldToGl,
      cameraZoom: cameraZoom,
      tileLocalToWorld: tileLocalToWorld,
      tileSize: tileSize,
      tileExtent: tileExtent,
      tileOpacity: tileOpacity,
    );
  }
}
