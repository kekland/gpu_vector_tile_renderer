// GENERATED FILE - DO NOT MODIFY
// Generated by lib/src/shaders/bindings/shader_bindings_generator.dart

import 'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings.dart';
import 'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings_utils.dart';
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:vector_math/vector_math_64.dart';

/// Generated UBO bindings for `BackgroundUbo`
class BackgroundUbo extends UniformBufferObjectBindings {
  BackgroundUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('BackgroundUbo'));

  void set({required Vector4 color, required double opacity}) {
    set_vec4(get_member_offset(slot, 'color'), data, color);
    set_float(get_member_offset(slot, 'opacity'), data, opacity);
    needsFlush = true;
  }
}

/// Generated UBO bindings for `MeadowUbo`
class MeadowUbo extends UniformBufferObjectBindings {
  MeadowUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('MeadowUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `Tile`
class TileUbo extends UniformBufferObjectBindings {
  TileUbo(gpu.Shader shader) : super(slot: shader.getUniformSlot('Tile'));

  void set({
    required Matrix4 localToWorld,
    required double size,
    required double extent,
    required double opacity,
  }) {
    set_mat4(get_member_offset(slot, 'local_to_world'), data, localToWorld);
    set_float(get_member_offset(slot, 'size'), data, size);
    set_float(get_member_offset(slot, 'extent'), data, extent);
    set_float(get_member_offset(slot, 'opacity'), data, opacity);
    needsFlush = true;
  }
}

/// Generated UBO bindings for `Camera`
class CameraUbo extends UniformBufferObjectBindings {
  CameraUbo(gpu.Shader shader) : super(slot: shader.getUniformSlot('Camera'));

  void set({required Matrix4 worldToGl, required double zoom}) {
    set_mat4(get_member_offset(slot, 'world_to_gl'), data, worldToGl);
    set_float(get_member_offset(slot, 'zoom'), data, zoom);
    needsFlush = true;
  }
}

/// Generated UBO bindings for `ScrubUbo`
class ScrubUbo extends UniformBufferObjectBindings {
  ScrubUbo(gpu.Shader shader) : super(slot: shader.getUniformSlot('ScrubUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `CropUbo`
class CropUbo extends UniformBufferObjectBindings {
  CropUbo(gpu.Shader shader) : super(slot: shader.getUniformSlot('CropUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `GlacierUbo`
class GlacierUbo extends UniformBufferObjectBindings {
  GlacierUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('GlacierUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `ForestUbo`
class ForestUbo extends UniformBufferObjectBindings {
  ForestUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('ForestUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `ResidentialUbo`
class ResidentialUbo extends UniformBufferObjectBindings {
  ResidentialUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('ResidentialUbo'));

  void set({required double colorStartStop, required double colorEndStop}) {
    set_float(
      get_member_offset(slot, 'color_start_stop'),
      data,
      colorStartStop,
    );
    set_float(get_member_offset(slot, 'color_end_stop'), data, colorEndStop);
    needsFlush = true;
  }
}

/// Generated UBO bindings for `IndustrialUbo`
class IndustrialUbo extends UniformBufferObjectBindings {
  IndustrialUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('IndustrialUbo'));

  void set({
    required double opacityStartStop,
    required double opacityEndStop,
    required double colorStartStop,
    required double colorEndStop,
  }) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    set_float(
      get_member_offset(slot, 'color_start_stop'),
      data,
      colorStartStop,
    );
    set_float(get_member_offset(slot, 'color_end_stop'), data, colorEndStop);
    needsFlush = true;
  }
}

/// Generated UBO bindings for `CemeteryUbo`
class CemeteryUbo extends UniformBufferObjectBindings {
  CemeteryUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('CemeteryUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `HospitalUbo`
class HospitalUbo extends UniformBufferObjectBindings {
  HospitalUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('HospitalUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `StadiumUbo`
class StadiumUbo extends UniformBufferObjectBindings {
  StadiumUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('StadiumUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated UBO bindings for `SchoolUbo`
class SchoolUbo extends UniformBufferObjectBindings {
  SchoolUbo(gpu.Shader shader)
    : super(slot: shader.getUniformSlot('SchoolUbo'));

  void set({required double opacityStartStop, required double opacityEndStop}) {
    set_float(
      get_member_offset(slot, 'opacity_start_stop'),
      data,
      opacityStartStop,
    );
    set_float(
      get_member_offset(slot, 'opacity_end_stop'),
      data,
      opacityEndStop,
    );
    needsFlush = true;
  }
}

/// Generated bindings for the vertex shader `background`
class BackgroundVertexShaderBindings extends VertexShaderBindings {
  BackgroundVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['background_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `background`
class BackgroundFragmentShaderBindings extends FragmentShaderBindings {
  BackgroundFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['background_frag']!);
}

/// Generated bindings for the render pipeline `background`
class BackgroundRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BackgroundVertexShaderBindings,
          BackgroundFragmentShaderBindings
        > {
  BackgroundRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: BackgroundVertexShaderBindings(shaderLibrary),
        fragment: BackgroundFragmentShaderBindings(shaderLibrary),
        ubos: [BackgroundUbo(shaderLibrary['background_vert']!)],
      );

  late final BackgroundUbo backgroundUbo = ubos[0] as BackgroundUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Vector4 backgroundUboColor,
    required double backgroundUboOpacity,
  }) {
    backgroundUbo.set(color: backgroundUboColor, opacity: backgroundUboOpacity);
  }
}

/// Generated bindings for the vertex shader `meadow`
class MeadowVertexShaderBindings extends VertexShaderBindings {
  MeadowVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['meadow_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `meadow`
class MeadowFragmentShaderBindings extends FragmentShaderBindings {
  MeadowFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['meadow_frag']!);
}

/// Generated bindings for the render pipeline `meadow`
class MeadowRenderPipelineBindings
    extends
        RenderPipelineBindings<
          MeadowVertexShaderBindings,
          MeadowFragmentShaderBindings
        > {
  MeadowRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: MeadowVertexShaderBindings(shaderLibrary),
        fragment: MeadowFragmentShaderBindings(shaderLibrary),
        ubos: [
          MeadowUbo(shaderLibrary['meadow_vert']!),
          TileUbo(shaderLibrary['meadow_vert']!),
          CameraUbo(shaderLibrary['meadow_vert']!),
        ],
      );

  late final MeadowUbo meadowUbo = ubos[0] as MeadowUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double meadowUboOpacityStartStop,
    required double meadowUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    meadowUbo.set(
      opacityStartStop: meadowUboOpacityStartStop,
      opacityEndStop: meadowUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `scrub`
class ScrubVertexShaderBindings extends VertexShaderBindings {
  ScrubVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['scrub_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `scrub`
class ScrubFragmentShaderBindings extends FragmentShaderBindings {
  ScrubFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['scrub_frag']!);
}

/// Generated bindings for the render pipeline `scrub`
class ScrubRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ScrubVertexShaderBindings,
          ScrubFragmentShaderBindings
        > {
  ScrubRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: ScrubVertexShaderBindings(shaderLibrary),
        fragment: ScrubFragmentShaderBindings(shaderLibrary),
        ubos: [
          ScrubUbo(shaderLibrary['scrub_vert']!),
          TileUbo(shaderLibrary['scrub_vert']!),
          CameraUbo(shaderLibrary['scrub_vert']!),
        ],
      );

  late final ScrubUbo scrubUbo = ubos[0] as ScrubUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double scrubUboOpacityStartStop,
    required double scrubUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    scrubUbo.set(
      opacityStartStop: scrubUboOpacityStartStop,
      opacityEndStop: scrubUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `crop`
class CropVertexShaderBindings extends VertexShaderBindings {
  CropVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['crop_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `crop`
class CropFragmentShaderBindings extends FragmentShaderBindings {
  CropFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['crop_frag']!);
}

/// Generated bindings for the render pipeline `crop`
class CropRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CropVertexShaderBindings,
          CropFragmentShaderBindings
        > {
  CropRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CropVertexShaderBindings(shaderLibrary),
        fragment: CropFragmentShaderBindings(shaderLibrary),
        ubos: [
          CropUbo(shaderLibrary['crop_vert']!),
          TileUbo(shaderLibrary['crop_vert']!),
          CameraUbo(shaderLibrary['crop_vert']!),
        ],
      );

  late final CropUbo cropUbo = ubos[0] as CropUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double cropUboOpacityStartStop,
    required double cropUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    cropUbo.set(
      opacityStartStop: cropUboOpacityStartStop,
      opacityEndStop: cropUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `glacier`
class GlacierVertexShaderBindings extends VertexShaderBindings {
  GlacierVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['glacier_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `glacier`
class GlacierFragmentShaderBindings extends FragmentShaderBindings {
  GlacierFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['glacier_frag']!);
}

/// Generated bindings for the render pipeline `glacier`
class GlacierRenderPipelineBindings
    extends
        RenderPipelineBindings<
          GlacierVertexShaderBindings,
          GlacierFragmentShaderBindings
        > {
  GlacierRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: GlacierVertexShaderBindings(shaderLibrary),
        fragment: GlacierFragmentShaderBindings(shaderLibrary),
        ubos: [
          GlacierUbo(shaderLibrary['glacier_vert']!),
          TileUbo(shaderLibrary['glacier_vert']!),
          CameraUbo(shaderLibrary['glacier_vert']!),
        ],
      );

  late final GlacierUbo glacierUbo = ubos[0] as GlacierUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double glacierUboOpacityStartStop,
    required double glacierUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    glacierUbo.set(
      opacityStartStop: glacierUboOpacityStartStop,
      opacityEndStop: glacierUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `forest`
class ForestVertexShaderBindings extends VertexShaderBindings {
  ForestVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['forest_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `forest`
class ForestFragmentShaderBindings extends FragmentShaderBindings {
  ForestFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['forest_frag']!);
}

/// Generated bindings for the render pipeline `forest`
class ForestRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ForestVertexShaderBindings,
          ForestFragmentShaderBindings
        > {
  ForestRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: ForestVertexShaderBindings(shaderLibrary),
        fragment: ForestFragmentShaderBindings(shaderLibrary),
        ubos: [
          ForestUbo(shaderLibrary['forest_vert']!),
          TileUbo(shaderLibrary['forest_vert']!),
          CameraUbo(shaderLibrary['forest_vert']!),
        ],
      );

  late final ForestUbo forestUbo = ubos[0] as ForestUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double forestUboOpacityStartStop,
    required double forestUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    forestUbo.set(
      opacityStartStop: forestUboOpacityStartStop,
      opacityEndStop: forestUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `sand`
class SandVertexShaderBindings extends VertexShaderBindings {
  SandVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['sand_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `sand`
class SandFragmentShaderBindings extends FragmentShaderBindings {
  SandFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['sand_frag']!);
}

/// Generated bindings for the render pipeline `sand`
class SandRenderPipelineBindings
    extends
        RenderPipelineBindings<
          SandVertexShaderBindings,
          SandFragmentShaderBindings
        > {
  SandRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: SandVertexShaderBindings(shaderLibrary),
        fragment: SandFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['sand_vert']!),
          CameraUbo(shaderLibrary['sand_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `wood`
class WoodVertexShaderBindings extends VertexShaderBindings {
  WoodVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['wood_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `wood`
class WoodFragmentShaderBindings extends FragmentShaderBindings {
  WoodFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['wood_frag']!);
}

/// Generated bindings for the render pipeline `wood`
class WoodRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WoodVertexShaderBindings,
          WoodFragmentShaderBindings
        > {
  WoodRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: WoodVertexShaderBindings(shaderLibrary),
        fragment: WoodFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['wood_vert']!),
          CameraUbo(shaderLibrary['wood_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `residential`
class ResidentialVertexShaderBindings extends VertexShaderBindings {
  ResidentialVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 40, shader: shaderLibrary['residential_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_vec4(offset + 8, vertexData!, colorStartValue);
    set_vec4(offset + 24, vertexData!, colorEndValue);
  }
}

/// Generated bindings for the fragment shader `residential`
class ResidentialFragmentShaderBindings extends FragmentShaderBindings {
  ResidentialFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['residential_frag']!);
}

/// Generated bindings for the render pipeline `residential`
class ResidentialRenderPipelineBindings
    extends
        RenderPipelineBindings<
          ResidentialVertexShaderBindings,
          ResidentialFragmentShaderBindings
        > {
  ResidentialRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: ResidentialVertexShaderBindings(shaderLibrary),
        fragment: ResidentialFragmentShaderBindings(shaderLibrary),
        ubos: [
          ResidentialUbo(shaderLibrary['residential_vert']!),
          TileUbo(shaderLibrary['residential_vert']!),
          CameraUbo(shaderLibrary['residential_vert']!),
        ],
      );

  late final ResidentialUbo residentialUbo = ubos[0] as ResidentialUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double residentialUboColorStartStop,
    required double residentialUboColorEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    residentialUbo.set(
      colorStartStop: residentialUboColorStartStop,
      colorEndStop: residentialUboColorEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `industrial`
class IndustrialVertexShaderBindings extends VertexShaderBindings {
  IndustrialVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 48, shader: shaderLibrary['industrial_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
    required Vector4 colorStartValue,
    required Vector4 colorEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
    set_vec4(offset + 16, vertexData!, colorStartValue);
    set_vec4(offset + 32, vertexData!, colorEndValue);
  }
}

/// Generated bindings for the fragment shader `industrial`
class IndustrialFragmentShaderBindings extends FragmentShaderBindings {
  IndustrialFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['industrial_frag']!);
}

/// Generated bindings for the render pipeline `industrial`
class IndustrialRenderPipelineBindings
    extends
        RenderPipelineBindings<
          IndustrialVertexShaderBindings,
          IndustrialFragmentShaderBindings
        > {
  IndustrialRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: IndustrialVertexShaderBindings(shaderLibrary),
        fragment: IndustrialFragmentShaderBindings(shaderLibrary),
        ubos: [
          IndustrialUbo(shaderLibrary['industrial_vert']!),
          TileUbo(shaderLibrary['industrial_vert']!),
          CameraUbo(shaderLibrary['industrial_vert']!),
        ],
      );

  late final IndustrialUbo industrialUbo = ubos[0] as IndustrialUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double industrialUboOpacityStartStop,
    required double industrialUboOpacityEndStop,
    required double industrialUboColorStartStop,
    required double industrialUboColorEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    industrialUbo.set(
      opacityStartStop: industrialUboOpacityStartStop,
      opacityEndStop: industrialUboOpacityEndStop,
      colorStartStop: industrialUboColorStartStop,
      colorEndStop: industrialUboColorEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `grass`
class GrassVertexShaderBindings extends VertexShaderBindings {
  GrassVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['grass_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `grass`
class GrassFragmentShaderBindings extends FragmentShaderBindings {
  GrassFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['grass_frag']!);
}

/// Generated bindings for the render pipeline `grass`
class GrassRenderPipelineBindings
    extends
        RenderPipelineBindings<
          GrassVertexShaderBindings,
          GrassFragmentShaderBindings
        > {
  GrassRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: GrassVertexShaderBindings(shaderLibrary),
        fragment: GrassFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['grass_vert']!),
          CameraUbo(shaderLibrary['grass_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `airport_zone`
class AirportZoneVertexShaderBindings extends VertexShaderBindings {
  AirportZoneVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['airport_zone_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `airport_zone`
class AirportZoneFragmentShaderBindings extends FragmentShaderBindings {
  AirportZoneFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['airport_zone_frag']!);
}

/// Generated bindings for the render pipeline `airport_zone`
class AirportZoneRenderPipelineBindings
    extends
        RenderPipelineBindings<
          AirportZoneVertexShaderBindings,
          AirportZoneFragmentShaderBindings
        > {
  AirportZoneRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: AirportZoneVertexShaderBindings(shaderLibrary),
        fragment: AirportZoneFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['airport_zone_vert']!),
          CameraUbo(shaderLibrary['airport_zone_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `pedestrian`
class PedestrianVertexShaderBindings extends VertexShaderBindings {
  PedestrianVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['pedestrian_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `pedestrian`
class PedestrianFragmentShaderBindings extends FragmentShaderBindings {
  PedestrianFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['pedestrian_frag']!);
}

/// Generated bindings for the render pipeline `pedestrian`
class PedestrianRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PedestrianVertexShaderBindings,
          PedestrianFragmentShaderBindings
        > {
  PedestrianRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PedestrianVertexShaderBindings(shaderLibrary),
        fragment: PedestrianFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['pedestrian_vert']!),
          CameraUbo(shaderLibrary['pedestrian_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `cemetery`
class CemeteryVertexShaderBindings extends VertexShaderBindings {
  CemeteryVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['cemetery_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `cemetery`
class CemeteryFragmentShaderBindings extends FragmentShaderBindings {
  CemeteryFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['cemetery_frag']!);
}

/// Generated bindings for the render pipeline `cemetery`
class CemeteryRenderPipelineBindings
    extends
        RenderPipelineBindings<
          CemeteryVertexShaderBindings,
          CemeteryFragmentShaderBindings
        > {
  CemeteryRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: CemeteryVertexShaderBindings(shaderLibrary),
        fragment: CemeteryFragmentShaderBindings(shaderLibrary),
        ubos: [
          CemeteryUbo(shaderLibrary['cemetery_vert']!),
          TileUbo(shaderLibrary['cemetery_vert']!),
          CameraUbo(shaderLibrary['cemetery_vert']!),
        ],
      );

  late final CemeteryUbo cemeteryUbo = ubos[0] as CemeteryUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double cemeteryUboOpacityStartStop,
    required double cemeteryUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    cemeteryUbo.set(
      opacityStartStop: cemeteryUboOpacityStartStop,
      opacityEndStop: cemeteryUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `hospital`
class HospitalVertexShaderBindings extends VertexShaderBindings {
  HospitalVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['hospital_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `hospital`
class HospitalFragmentShaderBindings extends FragmentShaderBindings {
  HospitalFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['hospital_frag']!);
}

/// Generated bindings for the render pipeline `hospital`
class HospitalRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HospitalVertexShaderBindings,
          HospitalFragmentShaderBindings
        > {
  HospitalRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: HospitalVertexShaderBindings(shaderLibrary),
        fragment: HospitalFragmentShaderBindings(shaderLibrary),
        ubos: [
          HospitalUbo(shaderLibrary['hospital_vert']!),
          TileUbo(shaderLibrary['hospital_vert']!),
          CameraUbo(shaderLibrary['hospital_vert']!),
        ],
      );

  late final HospitalUbo hospitalUbo = ubos[0] as HospitalUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double hospitalUboOpacityStartStop,
    required double hospitalUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    hospitalUbo.set(
      opacityStartStop: hospitalUboOpacityStartStop,
      opacityEndStop: hospitalUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `stadium`
class StadiumVertexShaderBindings extends VertexShaderBindings {
  StadiumVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['stadium_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `stadium`
class StadiumFragmentShaderBindings extends FragmentShaderBindings {
  StadiumFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['stadium_frag']!);
}

/// Generated bindings for the render pipeline `stadium`
class StadiumRenderPipelineBindings
    extends
        RenderPipelineBindings<
          StadiumVertexShaderBindings,
          StadiumFragmentShaderBindings
        > {
  StadiumRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: StadiumVertexShaderBindings(shaderLibrary),
        fragment: StadiumFragmentShaderBindings(shaderLibrary),
        ubos: [
          StadiumUbo(shaderLibrary['stadium_vert']!),
          TileUbo(shaderLibrary['stadium_vert']!),
          CameraUbo(shaderLibrary['stadium_vert']!),
        ],
      );

  late final StadiumUbo stadiumUbo = ubos[0] as StadiumUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double stadiumUboOpacityStartStop,
    required double stadiumUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    stadiumUbo.set(
      opacityStartStop: stadiumUboOpacityStartStop,
      opacityEndStop: stadiumUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `school`
class SchoolVertexShaderBindings extends VertexShaderBindings {
  SchoolVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 16, shader: shaderLibrary['school_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacityStartValue,
    required double opacityEndValue,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacityStartValue);
    set_float(offset + 12, vertexData!, opacityEndValue);
  }
}

/// Generated bindings for the fragment shader `school`
class SchoolFragmentShaderBindings extends FragmentShaderBindings {
  SchoolFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['school_frag']!);
}

/// Generated bindings for the render pipeline `school`
class SchoolRenderPipelineBindings
    extends
        RenderPipelineBindings<
          SchoolVertexShaderBindings,
          SchoolFragmentShaderBindings
        > {
  SchoolRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: SchoolVertexShaderBindings(shaderLibrary),
        fragment: SchoolFragmentShaderBindings(shaderLibrary),
        ubos: [
          SchoolUbo(shaderLibrary['school_vert']!),
          TileUbo(shaderLibrary['school_vert']!),
          CameraUbo(shaderLibrary['school_vert']!),
        ],
      );

  late final SchoolUbo schoolUbo = ubos[0] as SchoolUbo;
  late final TileUbo tileUbo = ubos[1] as TileUbo;
  late final CameraUbo cameraUbo = ubos[2] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required double schoolUboOpacityStartStop,
    required double schoolUboOpacityEndStop,
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    schoolUbo.set(
      opacityStartStop: schoolUboOpacityStartStop,
      opacityEndStop: schoolUboOpacityEndStop,
    );
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `water_intermittent`
class WaterIntermittentVertexShaderBindings extends VertexShaderBindings {
  WaterIntermittentVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        bytesPerVertex: 8,
        shader: shaderLibrary['water_intermittent_vert']!,
      );

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `water_intermittent`
class WaterIntermittentFragmentShaderBindings extends FragmentShaderBindings {
  WaterIntermittentFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['water_intermittent_frag']!);
}

/// Generated bindings for the render pipeline `water_intermittent`
class WaterIntermittentRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WaterIntermittentVertexShaderBindings,
          WaterIntermittentFragmentShaderBindings
        > {
  WaterIntermittentRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: WaterIntermittentVertexShaderBindings(shaderLibrary),
        fragment: WaterIntermittentFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['water_intermittent_vert']!),
          CameraUbo(shaderLibrary['water_intermittent_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `water`
class WaterVertexShaderBindings extends VertexShaderBindings {
  WaterVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 12, shader: shaderLibrary['water_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(
    int index, {
    required Vector2 position,
    required double opacity,
  }) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
    set_float(offset + 8, vertexData!, opacity);
  }
}

/// Generated bindings for the fragment shader `water`
class WaterFragmentShaderBindings extends FragmentShaderBindings {
  WaterFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['water_frag']!);
}

/// Generated bindings for the render pipeline `water`
class WaterRenderPipelineBindings
    extends
        RenderPipelineBindings<
          WaterVertexShaderBindings,
          WaterFragmentShaderBindings
        > {
  WaterRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: WaterVertexShaderBindings(shaderLibrary),
        fragment: WaterFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['water_vert']!),
          CameraUbo(shaderLibrary['water_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `heliport`
class HeliportVertexShaderBindings extends VertexShaderBindings {
  HeliportVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['heliport_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `heliport`
class HeliportFragmentShaderBindings extends FragmentShaderBindings {
  HeliportFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['heliport_frag']!);
}

/// Generated bindings for the render pipeline `heliport`
class HeliportRenderPipelineBindings
    extends
        RenderPipelineBindings<
          HeliportVertexShaderBindings,
          HeliportFragmentShaderBindings
        > {
  HeliportRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: HeliportVertexShaderBindings(shaderLibrary),
        fragment: HeliportFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['heliport_vert']!),
          CameraUbo(shaderLibrary['heliport_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `pier`
class PierVertexShaderBindings extends VertexShaderBindings {
  PierVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['pier_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `pier`
class PierFragmentShaderBindings extends FragmentShaderBindings {
  PierFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['pier_frag']!);
}

/// Generated bindings for the render pipeline `pier`
class PierRenderPipelineBindings
    extends
        RenderPipelineBindings<
          PierVertexShaderBindings,
          PierFragmentShaderBindings
        > {
  PierRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: PierVertexShaderBindings(shaderLibrary),
        fragment: PierFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['pier_vert']!),
          CameraUbo(shaderLibrary['pier_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `bridge`
class BridgeVertexShaderBindings extends VertexShaderBindings {
  BridgeVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['bridge_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `bridge`
class BridgeFragmentShaderBindings extends FragmentShaderBindings {
  BridgeFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['bridge_frag']!);
}

/// Generated bindings for the render pipeline `bridge`
class BridgeRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BridgeVertexShaderBindings,
          BridgeFragmentShaderBindings
        > {
  BridgeRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: BridgeVertexShaderBindings(shaderLibrary),
        fragment: BridgeFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['bridge_vert']!),
          CameraUbo(shaderLibrary['bridge_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}

/// Generated bindings for the vertex shader `building`
class BuildingVertexShaderBindings extends VertexShaderBindings {
  BuildingVertexShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(bytesPerVertex: 8, shader: shaderLibrary['building_vert']!);

  /// Sets attributes for a vertex at [index].
  ///
  /// Ensure that [allocateVertices] has been called before calling this method.
  void setVertex(int index, {required Vector2 position}) {
    final offset = index * bytesPerVertex;

    set_vec2(offset + 0, vertexData!, position);
  }
}

/// Generated bindings for the fragment shader `building`
class BuildingFragmentShaderBindings extends FragmentShaderBindings {
  BuildingFragmentShaderBindings(gpu.ShaderLibrary shaderLibrary)
    : super(shader: shaderLibrary['building_frag']!);
}

/// Generated bindings for the render pipeline `building`
class BuildingRenderPipelineBindings
    extends
        RenderPipelineBindings<
          BuildingVertexShaderBindings,
          BuildingFragmentShaderBindings
        > {
  BuildingRenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)
    : super(
        vertex: BuildingVertexShaderBindings(shaderLibrary),
        fragment: BuildingFragmentShaderBindings(shaderLibrary),
        ubos: [
          TileUbo(shaderLibrary['building_vert']!),
          CameraUbo(shaderLibrary['building_vert']!),
        ],
      );

  late final TileUbo tileUbo = ubos[0] as TileUbo;
  late final CameraUbo cameraUbo = ubos[1] as CameraUbo;

  /// Sets the UBOs for this shader.
  void setUbos({
    required Matrix4 tileLocalToWorld,
    required double tileSize,
    required double tileExtent,
    required double tileOpacity,
    required Matrix4 cameraWorldToGl,
    required double cameraZoom,
  }) {
    tileUbo.set(
      localToWorld: tileLocalToWorld,
      size: tileSize,
      extent: tileExtent,
      opacity: tileOpacity,
    );
    cameraUbo.set(worldToGl: cameraWorldToGl, zoom: cameraZoom);
  }
}
