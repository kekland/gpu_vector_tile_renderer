#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const scriptLocation = path.resolve(__dirname);
const rootLocation = path.resolve(scriptLocation, '..');
const shadersLocation = path.resolve(rootLocation, 'shaders');
const generatedLocation = path.resolve(rootLocation, 'lib', 'src', 'components', 'shaders', 'gen');

// Find shaderbundle file
const shaderBundleFile = fs.readdirSync(shadersLocation).find(file => file.endsWith('.shaderbundle.json'));

// Load shaderbundle file
const shaderBundle = JSON.parse(fs.readFileSync(path.resolve(shadersLocation, shaderBundleFile), 'utf8'));

const glslToDartTypes = {
  'vec2': 'Vector2',
  'vec3': 'Vector3',
  'vec4': 'Vector4',
  'mat4': 'Matrix4',
  'float': 'double',
  'int': 'int',
}

const glslTypeByteSize = {
  'float': 4,
  'int': 4,
  'vec2': 8,
  'vec3': 12,
  'vec4': 16,
  'mat4': 64,
}

const parseField = (line) => {
  const parts = line.split(' ');
  if (parts[0] === 'in') {
    parts.splice(0, 1);
  }

  const type = parts.slice(0, parts.length - 1).join(' ');
  const name = parts[parts.length - 1].replace(';', '');

  return { type, name };
}

const parseShaderCode = ({ type, code }) => {
  const uniformBlocks = [];
  const attributeFields = [];

  const lines = code.split('\n');
  for (const line of lines) {
    const trimmedLine = line.trim();

    if (trimmedLine.startsWith('uniform')) {
      const name = trimmedLine.split(' ')[1];
      const uniformBlock = { name: name, fields: [] };

      let i = lines.indexOf(line) + 1;
      while (i < lines.length) {
        const nextLine = lines[i].trim();
        if (nextLine.startsWith('}')) {
          break;
        }

        uniformBlock.fields.push(parseField(nextLine));
        i++;
      }

      uniformBlocks.push(uniformBlock);
    }
    else if (type === 'vertex' && trimmedLine.startsWith('in')) {
      attributeFields.push(parseField(trimmedLine));
    }
  }

  return { uniforms: uniformBlocks, attributes: attributeFields }
}

const generatedUbos = {}
const uboCode = [];

const generateUniformCode = (uniform) => {
  if (generatedUbos[uniform.name]) {
    // Check for deep equality
    const existingUniform = generatedUbos[uniform.name];

    if (JSON.stringify(existingUniform.fields) !== JSON.stringify(uniform.fields)) {
      console.error(`Fields for uniform ${uniform.name} do not match`);
    }

    return;
  }

  generatedUbos[uniform.name] = uniform;
  const code = [];

  console.log(uniform)

  const totalByteSize = uniform.fields.reduce((acc, field) => {
    return acc + glslTypeByteSize[field.type];
  }, 0);

  code.push(`class ${uniform.name}Ubo extends UniformBufferObjectBindings {`);
  code.push(`  ${uniform.name}Ubo(gpu.UniformSlot slot): super(slot, ${totalByteSize});`);
  code.push('');

  let setFunctionDeclaration = '  void set({';

  for (const field of uniform.fields) {
    const dartType = glslToDartTypes[field.type];
    setFunctionDeclaration += `required ${dartType} ${field.name}, `;
  }


  setFunctionDeclaration = setFunctionDeclaration.slice(0, -2);
  setFunctionDeclaration += '}) {';
  code.push(setFunctionDeclaration);

  var offset = 0;
  for (const field of uniform.fields) {
    let dartType;

    if (field.type === 'float') dartType = 'Float';
    else dartType = glslToDartTypes[field.type];

    code.push(`    set${dartType}(${offset}, data, ${field.name});`);
    offset += glslTypeByteSize[field.type];
  }

  code.push(`    onSetData();`);

  code.push('  }');
  code.push('}');
  code.push('');

  uboCode.push(code.join('\n'));
}

const generateShaderCode = ({ fileName, type, uniforms, attributes }) => {
  const code = []

  const className = `${fileName}Shader`;

  code.push('// GENERATED CODE - DO NOT MODIFY BY HAND');
  code.push('// Generated by tool/generate_shader_code.js');
  code.push('');
  code.push('// ignore_for_file: unused_import')
  code.push('');
  code.push('import \'../_shaders.dart\';')
  code.push('import \'./ubo.gen.dart\';');
  code.push('')
  code.push('import \'package:flutter_gpu/gpu.dart\' as gpu;')
  code.push('import \'package:vector_math/vector_math.dart\';');
  code.push('');

  for (const uniform of uniforms) {
    generateUniformCode(uniform)
  }

  if (type === 'vertex') {
    // code.push('  void set({')
    // code.push('    required int index,')

    // for (const attribute of attributes) {
    //   const dartType = glslToDartTypes[attribute.type];
    //   code.push(`    required ${dartType} ${attribute.name},`);
    // }

    // code.push('  }) {')

    // let offset = 0;
    // for (const attribute of attributes) {
    //   const dartType = glslToDartTypes[attribute.type];
    //   code.push(`    set${dartType}(index * bytesPerVertex + ${offset}, vertexData, ${attribute.name});`);
    //   offset += glslTypeByteSize[attribute.type];
    // }

    // code.push('  }')
    // code.push('')

    const bytesPerVertex = attributes.reduce((acc, attribute) => {
      return acc + glslTypeByteSize[attribute.type];
    }, 0);

    // code.push(`  @override`)
    // code.push(`  int get bytesPerVertex => ${bytesPerVertex};`)

    // code.push('}');
    // code.push('');

    code.push(`class ${className} extends VertexShaderBindings {`);
    code.push(`  ${className}() : super(${bytesPerVertex}, shaderLibrary['${fileName}']!)`)
  }
  else {
    code.push(`class ${className} extends FragmentShaderBindings {`);
    code.push(`  ${className}() : super(shaderLibrary['${fileName}']!)`)
  }

  if (uniforms.length > 0) {
    code.push('{')

    for (const uniform of uniforms) {
      code.push(`    ${camelToPascal(uniform.name)}Ubo = ${uniform.name}Ubo(shader.getUniformSlot('${uniform.name}'));`);
    }

    code.push('  }');
    code.push('');
  }
  else {
    code.push(';');
  }

  for (const uniform of uniforms) {
    code.push(`  late final ${uniform.name}Ubo ${camelToPascal(uniform.name)}Ubo;`);
  }

  code.push('');

  code.push('  @override')
  code.push('  List<UniformBufferObjectBindings> get ubos => [');

  for (const uniform of uniforms) {
    code.push(`    ${camelToPascal(uniform.name)}Ubo,`);
  }

  code.push('  ];');

  code.push('');

  if (type === 'vertex') {
    code.push('  void set(int index, {');

    for (const attribute of attributes) {
      const dartType = glslToDartTypes[attribute.type];
      code.push(`    required ${dartType} ${attribute.name},`);
    }

    code.push('  }) {');

    let offset = 0;

    for (const attribute of attributes) {
      const dartType = glslToDartTypes[attribute.type];
      code.push(`    set${dartType}(index * bytesPerVertex + ${offset}, vertexData!, ${attribute.name});`);
      offset += glslTypeByteSize[attribute.type];
    }

    code.push('}');
  }

  code.push('}');
  code.push('');

  return code.join('\n');
}

// Conert AaBb to aa_bb
const camelToSnake = (str) => {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`).slice(1);
}

// Convert AaBb to aaBb
const camelToPascal = (str) => {
  return str[0].toLowerCase() + str.slice(1);
}

// Remove and recreate generated folder
if (fs.existsSync(generatedLocation)) {
  fs.rmSync(generatedLocation, { recursive: true });
}

fs.mkdirSync(generatedLocation);

for (const shaderName in shaderBundle) {
  const { type, file } = shaderBundle[shaderName];
  const shaderCode = fs.readFileSync(path.resolve(rootLocation, file), 'utf8');

  const { uniforms, attributes } = parseShaderCode({ type, code: shaderCode });

  const fileName = `${camelToSnake(shaderName)}.gen.dart`;
  const filePath = path.resolve(generatedLocation, fileName);

  const generatedCode = generateShaderCode({ fileName: shaderName, type, uniforms, attributes });

  fs.writeFileSync(filePath, generatedCode);
}

const uboFilePath = path.resolve(generatedLocation, 'ubo.gen.dart');

const _uboCode = [
  '// GENERATED CODE - DO NOT MODIFY BY HAND',
  '// Generated by tool/generate_shader_code.js',
  '',
  '// ignore_for_file: unused_import',
  '',
  'import \'package:flutter_gpu/gpu.dart\' as gpu;',
  'import \'../_shaders.dart\';',
  'import \'package:vector_math/vector_math.dart\';',
  '',
  ...uboCode
];

fs.writeFileSync(uboFilePath, _uboCode.join('\n'));

// Run dart format on generated files
const { execSync } = require('child_process');

execSync(`dart format ${generatedLocation}/*.gen.dart --line-length=120`);