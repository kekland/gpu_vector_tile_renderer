import 'package:gpu_vector_tile_renderer/src/shaders/serializer/parsed_shader.dart';
import 'package:gpu_vector_tile_renderer/src/utils/string_utils.dart';

/// Generates the header for the shader bindings file.
String generateShaderBindingsHeader() {
  final o = StringBuffer();

  o.writeln('// GENERATED FILE - DO NOT MODIFY');
  o.writeln('// Generated by lib/src/shaders/bindings/shader_bindings_generator.dart');
  o.writeln();
  o.writeln('import \'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings.dart\';');
  o.writeln('import \'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings_utils.dart\';');
  o.writeln('import \'package:flutter_gpu/gpu.dart\' as gpu;');
  o.writeln('import \'package:vector_math/vector_math_64.dart\';');

  return o.toString();
}

/// Generates the common UBO bindings for a list of shaders.
String generateCommonShaderUboBindings(Iterable<ParsedShader> shaders) {
  final ubos = shaders.map((v) => v.ubos).expand((v) => v).toSet();

  final o = StringBuffer();

  // Generate UBO bindings
  for (final ubo in ubos) {
    final className = ubo.dartClassName;

    // -- Class declaration and constructor --
    o.writeln('/// Generated UBO bindings for `${ubo.name}`');
    o.writeln('class $className extends UniformBufferObjectBindings {');
    o.writeln('  $className(gpu.Shader shader): super(slot: shader.getUniformSlot(\'${ubo.name}\'));');
    o.writeln('');

    // -- UBO setter --
    o.write('  void set({');
    for (var i = 0; i < ubo.variables.length; i++) {
      final variable = ubo.variables[i];
      o.write('required ${variable.dartType} ${variable.dartName()}');
      if (i != ubo.variables.length - 1) o.write(', ');
    }
    o.writeln('}) {');
    for (final variable in ubo.variables) {
      o.writeln(
        '    set_${variable.typeGlsl.value}(get_member_offset(slot, \'${variable.name}\'), data, ${variable.dartName()});',
      );
    }
    o.writeln('    needsFlush = true;');
    o.writeln('  }');

    // -- Closing --
    o.writeln('}');
    o.writeln();
  }

  return o.toString();
}

/// Generates the shader bindings for a given [vertexShader] and [fragmentShader].
String generateShaderBindings(ParsedShaderVertex vertexShader, ParsedShaderFragment fragmentShader) {
  final o = StringBuffer();

  //
  // Generate vertex shader bindings
  //

  // -- Class declaration and constructor --
  o.writeln('/// Generated bindings for the vertex shader `${vertexShader.name}`');
  o.writeln('class ${vertexShader.dartClassName} extends VertexShaderBindings {');
  o.writeln('  ${vertexShader.dartClassName}(gpu.ShaderLibrary shaderLibrary)');
  o.writeln('    : super(');
  o.writeln('        bytesPerVertex: ${vertexShader.bytesPerVertex},');
  o.writeln('        shader: ${_generateShaderLibraryGetter(vertexShader)},');
  o.writeln('      );');
  o.writeln('');

  // -- Vertex attribute setter --
  o.writeln('  /// Sets attributes for a vertex at [index].');
  o.writeln('  /// ');
  o.writeln('  /// Ensure that [allocateVertices] has been called before calling this method.');
  o.write('  void setVertex(int index, {');
  for (var i = 0; i < vertexShader.attributes.length; i++) {
    final attribute = vertexShader.attributes.elementAt(i);
    o.write('required ${attribute.dartType} ${attribute.dartName()}');
    if (attribute != vertexShader.attributes.last) o.write(', ');
  }
  o.writeln('}) {');
  var offset = 0;
  o.writeln('    final offset = index * bytesPerVertex;');
  o.writeln('');
  for (var i = 0; i < vertexShader.attributes.length; i++) {
    final attribute = vertexShader.attributes.elementAt(i);
    o.writeln('    set_${attribute.typeGlsl.value}(offset + $offset, vertexData!, ${attribute.dartName()});');
    offset += attribute.sizeInBytes;
  }
  o.writeln('  }');
  o.writeln('');

  // -- Closing --
  o.writeln('}');
  o.writeln();

  //
  // Generate fragment shader bindings
  //

  // -- Class declaration
  o.writeln('/// Generated bindings for the fragment shader `${fragmentShader.name}`');
  o.writeln('class ${fragmentShader.dartClassName} extends FragmentShaderBindings {');
  o.writeln('  ${fragmentShader.dartClassName}(gpu.ShaderLibrary shaderLibrary)');
  o.writeln('    : super(');
  o.writeln('        shader: ${_generateShaderLibraryGetter(fragmentShader)},');
  o.writeln('      );');
  o.writeln('');

  // -- Closing --
  o.writeln('}');
  o.writeln();

  //
  // Generate pipeline bindings
  //

  final name = vertexShader.name;

  // -- Class declaration --
  o.writeln('/// Generated bindings for the render pipeline `$name`');
  o.writeln(
    'class ${nameToDartClassName(name)}RenderPipelineBindings extends RenderPipelineBindings<${vertexShader.dartClassName}, ${fragmentShader.dartClassName}> {',
  );
  o.writeln('  ${nameToDartClassName(name)}RenderPipelineBindings(gpu.ShaderLibrary shaderLibrary)');
  o.writeln('      : super(');
  o.writeln('          vertex: ${vertexShader.dartClassName}(shaderLibrary),');
  o.writeln('          fragment: ${fragmentShader.dartClassName}(shaderLibrary),');
  o.writeln('          ubos: [');
  o.write(_generateShaderPipelineConstructorUbos(vertexShader, fragmentShader));
  o.writeln('          ],');
  o.writeln('        );');

  if (vertexShader.ubos.isNotEmpty || fragmentShader.ubos.isNotEmpty) {
    // -- UBO getters --
    o.writeln('');
    o.write(_generateShaderPipelineUboGetters(vertexShader, fragmentShader));
    o.writeln('');

    // -- UBO setter --
    o.writeln(_generateShaderPipelineUboSetter(vertexShader, fragmentShader));
  }

  // -- Closing --
  o.writeln('}');
  o.writeln();

  return o.toString();
}

/// Generates a getter for the relevant shader library.
String _generateShaderLibraryGetter(ParsedShader shader) {
  return 'shaderLibrary[\'${shader.shaderBundleName}\']!';
}

/// Generates the initialization for UBOs in the shader pipeline constructor.
String _generateShaderPipelineConstructorUbos(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final ubos = {...vertexShader.ubos, ...fragmentShader.ubos};

  for (final ubo in ubos) {
    final shader = vertexShader.ubos.contains(ubo) ? vertexShader : fragmentShader;
    o.writeln('            ${ubo.dartClassName}(${_generateShaderLibraryGetter(shader)}),');
  }

  return o.toString();
}

/// Generates the UBO getters for the shader pipeline.
String _generateShaderPipelineUboGetters(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final ubos = {...vertexShader.ubos, ...fragmentShader.ubos};

  for (var i = 0; i < ubos.length; i++) {
    final ubo = ubos.elementAt(i);
    o.writeln(
      '  late final ${ubo.dartClassName} ${nameToDartFieldName(ubo.dartClassName)} = ubos[$i] as ${ubo.dartClassName};',
    );
  }

  return o.toString();
}

/// Generates the UBO setter for the shader pipeline.
String _generateShaderPipelineUboSetter(ParsedShader vertexShader, ParsedShader fragmentShader) {
  final o = StringBuffer();
  final ubos = {...vertexShader.ubos, ...fragmentShader.ubos};

  o.writeln('  /// Sets the UBOs for this shader.');
  o.writeln('  void setUbos({');
  for (var i = 0; i < ubos.length; i++) {
    final ubo = ubos.elementAt(i);

    for (var j = 0; j < ubo.variables.length; j++) {
      final variable = ubo.variables.elementAt(j);
      final paramName = nameToDartFieldName('${ubo.name}_${variable.dartName()}');
      o.write('required ${variable.dartType} $paramName');

      if (i != ubos.length - 1 || j != ubo.variables.length - 1) o.write(', ');
    }
  }
  o.writeln('}) {');
  for (final ubo in ubos) {
    o.writeln('    ${nameToDartFieldName(ubo.dartClassName)}.set(');
    for (var j = 0; j < ubo.variables.length; j++) {
      final variable = ubo.variables.elementAt(j);
      final paramName = nameToDartFieldName('${ubo.name}_${variable.dartName()}');
      o.write('${variable.dartName()}: $paramName');
      if (j != ubo.variables.length - 1) o.write(', ');
    }
    o.writeln(');');
  }

  o.writeln('  }');

  return o.toString();
}
