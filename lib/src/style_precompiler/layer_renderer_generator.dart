import 'package:gpu_vector_tile_renderer/src/shaders/serializer/parsed_shader.dart';
import 'package:gpu_vector_tile_renderer/src/spec/spec.dart';
import 'package:gpu_vector_tile_renderer/src/utils/string_utils.dart';

String generateLayerRenderers(List<Layer> layers, List<ParsedShader> shaders) {
  final o = StringBuffer();

  final vertexShaders = shaders.whereType<ParsedShaderVertex>();
  final fragmentShaders = shaders.whereType<ParsedShaderFragment>();

  o.writeln('// GENERATED FILE - DO NOT MODIFY');
  o.writeln('// Generated by lib/src/style_precompiler/layer_renderer_generator.dart');
  o.writeln();
  o.writeln('import \'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings.dart\';');
  o.writeln('import \'package:gpu_vector_tile_renderer/src/shaders/bindings/shader_bindings_utils.dart\';');
  o.writeln('import \'package:gpu_vector_tile_renderer/_renderer.dart\';');
  o.writeln('import \'package:gpu_vector_tile_renderer/_spec.dart\' as spec;');
  o.writeln('import \'package:gpu_vector_tile_renderer/_vector_tile.dart\' as vt;');
  o.writeln('import \'package:flutter_gpu/gpu.dart\' as gpu;');
  o.writeln('import \'package:vector_math/vector_math_64.dart\';');
  o.writeln();
  o.writeln('import \'./shader_bindings.gen.dart\';');
  o.writeln();

  for (final layer in layers) {
    if (layer.type != Layer$Type.fill) continue;

    final vertexShader = vertexShaders.firstWhere((s) => s.name == toSnakeCase(layer.id));
    final fragmentShader = fragmentShaders.firstWhere((s) => s.name == toSnakeCase(layer.id));

    o.writeln(_generateLayerRendererCode(layer, vertexShader, fragmentShader));
    o.writeln();
  }

  return o.toString();
}

String _generateLayerRendererCode(Layer layer, ParsedShaderVertex vertexShader, ParsedShaderFragment fragmentShader) {
  // currently only fills are supported
  assert(layer.type == Layer$Type.fill);

  final layerClassName = nameToDartClassName(toSnakeCase(layer.id));

  final className = '${layerClassName}LayerRenderer';
  final pipelineClassName = '${layerClassName}RenderPipelineBindings';

  final o = StringBuffer();

  o.writeln('class $className extends FillLayerRenderer {');
  o.writeln(
    '  $className({required gpu.ShaderLibrary shaderLibrary, required super.coordinates, required super.container, required super.specLayer, required super.vtLayer}) : pipeline = $pipelineClassName(shaderLibrary);',
  );

  o.writeln();
  o.writeln('  @override');
  o.writeln('  final $pipelineClassName pipeline;');
  o.writeln();
  o.writeln('  @override');
  o.writeln('  int setFeatureVertices(spec.EvaluationContext context, vt.PolygonFeature feature, int index) {');

  for (final attribute in vertexShader.attributes) {
    print(attribute.name);
  }

  o.writeln('  }');
  o.writeln();
  o.writeln('  @override');
  o.writeln(
    '  void setUniforms(RenderContext context, Matrix4 cameraWorldToGl, double cameraZoom, Matrix4 tileLocalToWorld, double tileSize, double tileExtent, double tileOpacity) {',
  );
  o.writeln('  }');

  o.writeln('}');

  return o.toString();
}
